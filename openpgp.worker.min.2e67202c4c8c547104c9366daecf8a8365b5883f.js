/*! OpenPGP.js v4.8.0 - 2020-01-14 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. */
!function(){return function e(n,t,r){function o(a,s){if(!t[a]){if(!n[a]){var u="function"==typeof require&&require;if(!s&&u)return u(a,!0);if(i)return i(a,!0);var c=new Error("Cannot find module '"+a+"'");throw c.code="MODULE_NOT_FOUND",c}var f=t[a]={exports:{}};n[a][0].call(f.exports,function(e){return o(n[a][1][e]||e)},f,f.exports,e,n,t,r)}return t[a].exports}for(var i="function"==typeof require&&require,a=0;a<r.length;a++)o(r[a]);return o}}()({1:[function(e,n,t){var r=window.openpgp,o=[],i=6e4;r.crypto.random.randomBuffer.init(i,function(){return o.length||self.postMessage({event:"request-seed",amount:i}),new Promise(function(e){o.push(e)})}),self.onmessage=function(e){var n,t=e.data||{};switch(t.event){case"configure":n=t.config,Object.keys(n).forEach(function(e){r.config[e]=n[e]});break;case"seed-random":!function(e){e instanceof Uint8Array||(e=new Uint8Array(e));r.crypto.random.randomBuffer.set(e)}(t.buf);var i=o;o=[];for(var a=0;a<i.length;a++)i[a]();break;default:!function(e,n,t){if("function"!=typeof r[n])return void u({id:e,event:"method-return",err:"Unknown Worker Event"});r.util.restoreStreams(t),(t=r.packet.clone.parseClonedPackets(t,n)).publicKeys&&(t.publicKeys=t.publicKeys.map(s));t.privateKeys&&(t.privateKeys=t.privateKeys.map(s));r[n](t).then(function(n){u({id:e,event:"method-return",data:r.packet.clone.clonePackets(n)})}).catch(function(n){r.util.print_debug_error(n),u({id:e,event:"method-return",err:n.message,stack:n.stack})})}(t.id,t.event,t.options||{})}};const a=new Map;function s(e){const n=e.armor();return a.has(n)?a.get(n):(a.set(n,e),e)}function u(e){self.postMessage(e,r.util.getTransferables(e.data,!0))}postMessage({event:"loaded"})},{}]},{},[1]);